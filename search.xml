<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello, Selina~</title>
    <url>/2021/01/01/Hello-Selina/</url>
    <content><![CDATA[<p><strong>Hi, happy new year, welcome to the cosmos!</strong></p>
<p>​    – The first words of this world.</p>
]]></content>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka  原理学习</title>
    <url>/2021/01/09/Kafka-%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式的，发布订阅模式消息处理系统（也可以当做日志系统），常见可以用于web/nginx日志、访问日志，消息服务、流转处理等。<br>主要应用场景是：日志收集系统和消息系统。<br>Kafka主要设计目标如下：</p>
<ul>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>Scale out支持在线水平扩展</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>解耦<br>消息队列在处理过程中间插入了一个隐含的、基于数据的<strong>接口层</strong>，两边的处理过程都要实现这一接口。允许独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
</li>
<li><p>冗余<br>有些情况下，处理数据的过程会失败。除非<strong>数据被持久化</strong>，否则将造成丢失。Kafka把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。其他的许多消息队列多采用”插入-获取-删除”方式，不能保证数据处理失败场景中，再次找到并重新处理该数据。</p>
</li>
<li><p>扩展性<br>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的数据量是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p>
</li>
<li><p>灵活性 &amp; 峰值处理能力<br>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
</li>
<li><p>可恢复性<br>当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。这种允许重试或者延后处理请求的能力是Kafka与其他系统的区别。</p>
</li>
<li><p>送达保证<br>其他的部分消息系统提供了一个”只送达一次”保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。Kafka提供的冗余机制保证了消息能被实际的处理。是因为获取一个消息只是”预定”了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。</p>
</li>
<li><p>顺序保证<br>在大多使用场景下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。部分消息系统保证消息通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索他们的位置。</p>
</li>
<li><p>缓冲<br>在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行–写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</p>
</li>
<li><p>理解数据流<br>在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息队列通过消息被处理的频率，来辅助识别那些表现不佳的处理过程或领域，这些地方的数据流不是最优的。</p>
</li>
<li><p>异步通信<br>很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。</p>
</li>
</ol>
<h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><table>
<thead>
<tr>
<th align="left">名词</th>
<th align="left">释义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Producer</td>
<td align="left">生产者，负责发布消息到broker的客户端。</td>
</tr>
<tr>
<td align="left">Consumer</td>
<td align="left">消费者，从broker读取消息的客户端。</td>
</tr>
<tr>
<td align="left">Topic</td>
<td align="left">Kafka对消息进行归类，生产者发送到集群的每一条消息都要指定一个topic。</td>
</tr>
<tr>
<td align="left">Broker</td>
<td align="left">一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。</td>
</tr>
<tr>
<td align="left">Partition</td>
<td align="left">为了实现水平扩展能力，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序</td>
</tr>
<tr>
<td align="left">ConsumerGroup</td>
<td align="left">每个consumer属于一个特定的consumer group，一条消息可以发送到不同的consumer group，但一个consumer group中只能有一个consumer能消费这条消息。通过consumer group机制，kafka可以实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的实现。</td>
</tr>
<tr>
<td align="left">Offset</td>
<td align="left">kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka。</td>
</tr>
<tr>
<td align="left">Leader</td>
<td align="left">每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</td>
</tr>
<tr>
<td align="left">Follower</td>
<td align="left">Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</td>
</tr>
</tbody></table>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/images/articleimg/kafka%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="架构"><br>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><ol>
<li>启动 ZooKeeper 的 server；</li>
<li>启动 Kafka 的 server；</li>
<li>Producer 生产数据，然后通过 ZooKeeper 找到 Broker，再将数据 push 到 Broker 保存；</li>
<li>Consumer 通过 ZooKeeper 找到 Broker，然后再主动 pull 数据。</li>
</ol>
<h3 id="Kafka零拷贝技术"><a href="#Kafka零拷贝技术" class="headerlink" title="Kafka零拷贝技术"></a>Kafka零拷贝技术</h3><p>kafka的高性能是通过宏观架构、分布式partition存储、ISR数据同步、高效利用磁盘/系统特性。零拷贝技术属于利用系统特性的内容。</p>
<h4 id="传统IO流程："><a href="#传统IO流程：" class="headerlink" title="传统IO流程："></a>传统IO流程：</h4><p>比如读文件，再从socket发送出去，经过4次copy，如下图所示。<br><img src="/images/articleimg/kafkatraditioncopy.jpg" alt="传统拷贝"><br>1、第一次：将磁盘文件，读取到操作系统内核缓冲区；<br>2、第二次：将内核缓冲区的数据，copy到application应用程序的buffer；<br>3、第三步：将application应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区)；<br>4、第四次：将socket buffer的数据，copy到网卡，由网卡进行网络传输。<br>在应用不需要修改数据的场景中，第二三次拷贝到用户空间的操作是冗余的。而且实际IO读写，需要进行IO中断，需要CPU响应中断(带来上下文切换)，尽管后来引入DMA来接管CPU的中断请求，但四次copy仍然是对效率的浪费。</p>
<h4 id="零拷贝在kafka的应用："><a href="#零拷贝在kafka的应用：" class="headerlink" title="零拷贝在kafka的应用："></a>零拷贝在kafka的应用：</h4><p>零拷贝并不是不需要拷贝，而是减少不必要的拷贝次数。通常是说在IO读写过程中。<br>Kafka在以下两个流程中实现了高效读取磁盘的特性（通常磁盘比内存性能差距较大）。</p>
<ul>
<li>网络数据持久化到磁盘 (Producer 到 Broker)</li>
</ul>
<p>1.a. 顺序写磁盘：将来自Producer的数据，顺序追加在partition，partition就是一个文件，以此实现顺序写入。<br>1.b. mmap文件映射（零拷贝技术）：mmap将磁盘文件映射到内存，支持读和写，对内存的操作会反映在磁盘文件上。</p>
<ul>
<li>磁盘文件通过网络发送（Broker 到 Consumer）</li>
</ul>
<p>2.a. 顺序读磁盘：Consumer从broker读取数据时，因为自带了偏移量，接着上次读取的位置继续读，以此实现顺序读。<br>2.b. sendfile(in, out)（零拷贝技术）： 是将磁盘文件直接拷贝到内核空间，然后将读到内核空间的数据，转到socket buffer，进行网络发送。</p>
<h4 id="零拷贝技术："><a href="#零拷贝技术：" class="headerlink" title="零拷贝技术："></a>零拷贝技术：</h4><ul>
<li><p>mmap(Memory Mapped Files)<br>简称mmap，将磁盘文件映射到进程的虚拟地址中，用户可以通过对内存的操作完成对应文件的读写，省去了用户空间到内核空间的开销。<br>mmap有一个缺点是不可靠，写到mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用flush的时候才把数据真正的写到硬盘。Kafka提供了一个参数——producer.type来控制是不是主动flush；如果Kafka写入到mmap之后就立即flush然后再返回Producer叫同步(sync)；写入mmap之后立即返回Producer不调用flush叫异步(async)。</p>
</li>
<li><p>sendfile<br>Linux 2.4+ 内核通过 sendfile 系统调用提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，相比传统IO的4次copy，减少了2次 CPU 拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件 - 网络发送由一个 sendfile 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。零拷贝过程如下图所示。<br><img src="/images/articleimg/kafkazerocopy.jpg" alt="传统拷贝"><br>这项零拷贝技术，直接从内核空间（DMA的）到内核空间（Socket的)、然后发送网卡。<br>应用的场景非常多，如Tomcat、Nginx、Apache等web服务器返回静态资源等，将数据用网络发送出去，都运用了sendfile。</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>消息通信框架：<br>用途：负责数据在不同应用间的发送，应用层只需要聚焦于数据，无需关注数据在多个应用间的传递过程。<br>类型：</p>
<ul>
<li>点对点模式：消息被发送到一个队列中。可能有一个或多个消费者处理队列中数据，但数据被消费一次后，就从队列中删除，生产者发送一条消息到队列，只有一个消费者能收到。</li>
<li>发布-订阅模式：消息被发送到一个topic。消息的生产者称为发布者，消费者称为订阅者。发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。订阅者可以订阅一个或多个topic，订阅者可以消费该topic中所有的数据，同一条数据可以被多个订阅者消费，数据被消费后不会立马删除。Kafka属于该模式。</li>
</ul>
</li>
<li><p>为什么说kafka是分布式模型呢？<br>首先，同一个kafka集群有共同拥有一个topic, 而同一个topic又拥有不同的分区，不同的分区可以分布在不同的borker上也就是不同的机子上，由于分区是分布式的，那么数据也是分布式存储了。<br>还有消费者也是分布式的，比如，消费者组里的消费者可以在不同的机器上，有什么好处？消费的方式可以是存储可以是计算，如果是放在一台机子上，Io等压力很大。<br>kafka上面的所有想到的角色都是分布式的，不管是消费者还是生产者还是分区，他们之间沟通的唯一桥梁就是zookeeper。这样看来，Kafka就是分布式模型了。</p>
</li>
</ul>
<p>链接：<br>Kafka官网：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a><br>Kafka深度解析：<a href="http://www.jasongj.com/2015/01/02/Kafka%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">http://www.jasongj.com/2015/01/02/Kafka%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</a><br>零拷贝：<a href="https://zhuanlan.zhihu.com/p/78335525">https://zhuanlan.zhihu.com/p/78335525</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>开源软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Github + Hexo Website Creation Guide</title>
    <url>/2021/01/02/github-and-hexo-website-create/</url>
    <content><![CDATA[<p><strong>页内导航</strong></p>
<ul>
<li>搭建 Node.js 环境</li>
<li>安装配置 Hexo</li>
<li>GitHub 注册和配置GitHub Pages</li>
<li>搭建 Git 环境</li>
<li>配置 Git 个人信息</li>
<li>关联 Hexo 与 GitHub</li>
<li>获得个人网站域名</li>
<li>GitHub Pages 地址绑定个人域名</li>
<li>小知识++<a id="more"></a>

</li>
</ul>
<h3 id="搭建-Node-js-环境"><a href="#搭建-Node-js-环境" class="headerlink" title="搭建 Node.js 环境"></a>搭建 Node.js 环境</h3><p>为什么要搭建 Node.js 环境？<br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 Hexo 博客系统是基于 Node.js 编写的。<br>在 Node.js 官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> 下载并安装，然后打开命令提示符，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>出现版本号则说明 Node.js 环境配置成功。</p>
<h3 id="安装配置-Hexo"><a href="#安装配置-Hexo" class="headerlink" title="安装配置 Hexo"></a>安装配置 Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>Hexo 的官方文档：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a> （强烈推荐看一看）<br>安装Hexo，中途看到WARN不用担心，不会影响正常使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>查看版本号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<p>安装 Hexo 完成后，请执行下列命令来初始化 Hexo，用户名改成你的，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog.github.io</span><br><span class="line"><span class="built_in">cd</span> myblog.github.io</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹的目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy         <span class="comment">#需要部署的文件</span></span><br><span class="line">├── node_modules    <span class="comment">#Hexo插件</span></span><br><span class="line">├── public          <span class="comment">#生成的静态网页文件</span></span><br><span class="line">├── scaffolds       <span class="comment">#模板</span></span><br><span class="line">├── <span class="built_in">source</span>          <span class="comment">#博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</span></span><br><span class="line">| ├── _drafts       <span class="comment">#草稿</span></span><br><span class="line">| └── _posts        <span class="comment">#文章</span></span><br><span class="line">├── themes          <span class="comment">#主题</span></span><br><span class="line">├── _config.yml     <span class="comment">#全局配置文件</span></span><br><span class="line">└── package.json    <span class="comment">#npm 依赖等</span></span><br></pre></td></tr></table></figure>
<p>运行本地 Hexo 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>网站会在 <a href="http://localhost:4000/">http://localhost:4000</a> 下启动。如果 <a href="http://localhost:4000/">http://localhost:4000</a> 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。</p>
<h3 id="GitHub-注册和配置-GitHub-Pages"><a href="#GitHub-注册和配置-GitHub-Pages" class="headerlink" title="GitHub 注册和配置 GitHub Pages"></a>GitHub 注册和配置 GitHub Pages</h3><p>Github官网：<a href="https://github.com/">https://github.com/</a> 注册账号<br>网站右上角+号 -&gt; New Repositories创建新项目 -&gt; Repositories name: yourname.github.io。yourname为你的github用户名，访问yourname.github.io正常说明github Pages配置成功。</p>
<h3 id="搭建-Git-环境"><a href="#搭建-Git-环境" class="headerlink" title="搭建 Git 环境"></a>搭建 Git 环境</h3><p>在 Git 官网：<a href="https://git-scm.com/">https://git-scm.com/</a> 下载并安装，桌面右键，打开 Git Bush Here，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>出现版本号则说明 Git 环境配置成功。</p>
<h3 id="配置-Git-个人信息"><a href="#配置-Git-个人信息" class="headerlink" title="配置 Git 个人信息"></a>配置 Git 个人信息</h3><p>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourgithubname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;yourregedmail@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了免于多次提交重复输入账户密码，配置如下信息，store永久保存密码，建议个人电脑；cache为临时保存账户信息，建议公共电脑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br><span class="line">or</span><br><span class="line">git config --global credential.helper cache</span><br></pre></td></tr></table></figure>
<p>查看配置内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<p>生成ssh秘钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>输出公钥，并拷贝的剪切板：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>GitHub -&gt; Setting -&gt; SSH and GPC keys -&gt; SSH keys -&gt; New SSH key -&gt; 将刚刚拷贝的公钥内容黏贴进去 -&gt; Add SSH key。<br>然后在Git Bash中检测GitHub公钥设置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>
<p>返回如下信息即成功配置秘钥，You’ve successfully authenticated.<br>这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p>
<h3 id="关联-Hexo-与-Github"><a href="#关联-Hexo-与-Github" class="headerlink" title="关联 Hexo 与 Github"></a>关联 Hexo 与 Github</h3><p>打开刚刚生成站点目录，第一级目录中有配置文件_config.yml，修改如下条目并保存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    <span class="built_in">type</span>: git</span><br><span class="line">    repo: https://github.com/youname.github.io.git GitHub上新仓库的路径</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>这时，我们分别输入三条命令，清除历史内容，生成新页面，部署网站：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>这时你的博客已经上线了，可以在公网上通过youname.github.io访问了。</p>
<h3 id="获得个人网站域名"><a href="#获得个人网站域名" class="headerlink" title="获得个人网站域名"></a>获得个人网站域名</h3><p>域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：<a href="https://www.ele.me/">https://www.ele.me/</a> ，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，建议选择常见的后缀，网站的搜索优化也较为友好。另外很多小众奇特的后缀在国内是没办法备案的，网站也就无法上线，该信息根据各省情况不同，如果需要的话可以进一步查询。</p>
<p>申请域名的地方有很多，比如NameSilo、西部数据、阿里云、腾讯云等，这里推荐阿里云：<a href="https://wanwang.aliyun.com/domain/">https://wanwang.aliyun.com/domain/</a> 。如果你已经有了空闲域名就无需购买，直接使用即可。<br>新申请的域名需要实名认证后才能正常解析，提交申请后预计1-3天就ok。</p>
<h3 id="GitHub-Pages-地址绑定个人域名"><a href="#GitHub-Pages-地址绑定个人域名" class="headerlink" title="GitHub Pages 地址绑定个人域名"></a>GitHub Pages 地址绑定个人域名</h3><p>Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。<br>github.io为自己站点的二级域名，该域名在百度等搜索引擎收录权重较低，也为了有自己独立的站点，因此将博客绑定到自己的域名。</p>
<h5 id="阿里云操作："><a href="#阿里云操作：" class="headerlink" title="阿里云操作："></a>阿里云操作：</h5><p>登陆阿里云，进入管理控制台的域名列表，找到你的域名，添加如下2条解析：<br>CNAME类型：记录类型选择CNAME -&gt; 主机记录填www -&gt; 解析线路选择默认 -&gt; 记录值填yourname.github.io -&gt; TTL值为10分钟<br>A类型：再添加一个解析，记录类型A -&gt; 主机记录填www -&gt; 解析线路选择默认 -&gt; 记录值填你GitHub 的ip地址（在cmd中ping：） -&gt; ping youname.github.io</p>
<h5 id="GitHub操作："><a href="#GitHub操作：" class="headerlink" title="GitHub操作："></a>GitHub操作：</h5><p>项目主页 -&gt; Settings-&gt;GitHub Pages -&gt; Source Branch:修改为master  -&gt; Custom domain:修改自己的域名，例如hexo.com<br>由于Hexo重新部署时会冲掉远端仓库配置的CNAME，解决方法是在本地的source目录下新建CNAME文件，填入hexo.com ，这样每次推送更新时，不需要登陆GitHub页面更新域名。<br>点击保存，等待10分钟后就可以使用自定义的域名，访问网站测试，正常访问即表示域名解析成功了。</p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识++"></a>小知识++</h3><h5 id="更改GitHub默认显示分支："><a href="#更改GitHub默认显示分支：" class="headerlink" title="更改GitHub默认显示分支："></a>更改GitHub默认显示分支：</h5><p>当前GitHub默认分支为main，更改为常见的master。<br>项目主页-&gt; Settings-&gt;Branches-&gt;Default branch:修改为master</p>
<h5 id="butterfly-Hexo主题："><a href="#butterfly-Hexo主题：" class="headerlink" title="butterfly Hexo主题："></a>butterfly Hexo主题：</h5><p>源码：<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a><br>指导手册：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a><br>作者博客：<a href="https://jerryc.me/">https://jerryc.me/</a><br>博客：<a href="http://www.rwyqboy.top/">http://www.rwyqboy.top/</a><br>站点美化：<a href="https://butterfly.lete114.top/article/Butterfly-config.html">Lete乐特</a>; <a href="https://www.antmoe.com/posts/a811d614/index.html">小康</a>; <a href="https://akilar.top/posts/7c16c4bb/">Hexo日记</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo - Quick Start Guide</title>
    <url>/2021/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">or</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">or</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">or</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法概述</title>
    <url>/2021/01/24/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>导语：英语语法的目的是造句，其核心就是<strong>动词</strong>，动词几乎能串起所有整个英语语法体系。<br><img src="/images/articleimg/EnglishGrammar.png" alt="语法体系的主体框架"></p>
<h3 id="简单句-simple-sentences"><a href="#简单句-simple-sentences" class="headerlink" title="简单句(simple sentences)"></a>简单句(simple sentences)</h3><p>几乎所有的英语句子都是：什么+怎么样结构，即主＋谓结构<br>主语: 人或物<br>谓语: 发生了什么事（”动作”）<br>简单句的5种基本句型：</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>动词种类</th>
<th>句型</th>
<th>例句</th>
</tr>
</thead>
<tbody><tr>
<td>可以独立完成的动作</td>
<td>不及物动词</td>
<td>主语 ＋（不及物）动词</td>
<td>papa rabbit sleeps.</td>
</tr>
<tr>
<td>有一个动作的承受者</td>
<td>单及物动词</td>
<td>主语＋（及物）动词＋宾语</td>
<td>papa rabbit likes you.</td>
</tr>
<tr>
<td>有两个动作承受者</td>
<td>双及物动词</td>
<td>主语＋（双及物）动词＋间宾＋直宾</td>
<td>papa rabbit tea ches you english.</td>
</tr>
<tr>
<td>只有一个动作承受者（ 不同于2）</td>
<td>复杂及物动词</td>
<td>主语＋（复杂及物）动词＋宾语＋（宾语）补语</td>
<td>papa rabbit considers you smart.</td>
</tr>
<tr>
<td>不是个”动作”</td>
<td>（连）系动词</td>
<td>主语 ＋ （系）动词＋（主语）补语（也叫表语）</td>
<td>papa rabbit is tall.</td>
</tr>
</tbody></table>
<p>PS：<br>1.宾语：动作的承受者。<br>2.间接宾语一般为人，.直接宾语一般为物。如上教授的知识是英语，而知识的接受对象是你。这里可以讲兔教英语，完整了，英语是直接宾语；但讲兔教你，没上下文的话是缺内容的，所以你是间接宾语。<br>3.连系动词：linking而已，代表“=”，即赋予主语某种性质状态划等号的动词，后者为前者的一种属性。<br>4.及物动词：没有承受者就没有实际意义，如like。<br>5.宾语补足语（补语）：补充承受者的信息才能使得句意完整，复杂及物动词必须要该结构才能组成句子，如上表的smart。<br>6.主语补足语（表语）：补充说明主语的属性，用于主系表中。<br>7.谓语和谓语动词：句子主语后面余下的句子部分就是谓语；谓语动词知识谓语的一部分。<br>8.7强调谓语动词，是因为还有非谓语动词。<br>9.定语：用来修饰主语或宾语。eg：<strong>the little white</strong> rabbit ate <strong>a large</strong> carrot.<br>10.状语：用来修饰谓语动词。eg：the rabbit ate <strong>quickly</strong>.<br>11.同位语：用来把主语或宾语用不同方式再说一遍，像唐僧。。eg：papa rabbit, <strong>an english teacher</strong>, eats a carrot. eg：我，秦始皇，打钱！</p>
<p>英语中涉及的所有<strong>句子成分</strong>只有8种，上面都分析到了，这里做个小结：<br><img src="/images/articleimg/partsOfSpeech.png" alt="句子8种成分"></p>
<h3 id="复合句-amp-复杂句"><a href="#复合句-amp-复杂句" class="headerlink" title="复合句 &amp; 复杂句"></a>复合句 &amp; 复杂句</h3><p>上面讲的都为简单句，但平时不都是简单句的使用，会把简单句组合，形成复合句和复杂句。<br>compound sentences 复合句（并列句）：简单句+简单句，句子简单的叠加，是并列关系。</p>
<p>complex sentences 复杂句：一个句子套在另一个句子里，可以一直套娃，是从属关系。（坑：有的语法书叫成了复合句，误导人儿）<br>主句和从句：句子套句子操作：语法中分别叫main clause 主句；subordinate clause 从句。从句说白了就是把简单句修改一下，做另一个句子的<strong>句子成分</strong>。<br>英语这种“套娃”的从句，和中文习惯差别大，所以是语法的难点之一。<br><img src="/images/articleimg/subordinateClause.png" alt="从句"></p>
<h3 id="词类"><a href="#词类" class="headerlink" title="词类"></a>词类</h3><p>词性（词类）：句子成分和单词类型是两个概念，就是同一类句子成分里可能有不同的词类。<br>英语的10大词类：</p>
<table>
<thead>
<tr>
<th>中文</th>
<th>english</th>
<th>说明</th>
<th>例句</th>
</tr>
</thead>
<tbody><tr>
<td>名词</td>
<td>nouns</td>
<td>表人和物</td>
<td><strong>papa rabbit</strong> is a <strong>rabbit</strong>.</td>
</tr>
<tr>
<td>冠词</td>
<td>articles</td>
<td>说明人和物</td>
<td>papa rabbit is <strong>a</strong> rabbit</td>
</tr>
<tr>
<td>代词</td>
<td>pronouns</td>
<td>代替人和物</td>
<td><strong>i</strong> am a rabbit.</td>
</tr>
<tr>
<td>形容词</td>
<td>adjectives</td>
<td>形容人和物</td>
<td>i am a <strong>smart</strong> rabbit</td>
</tr>
<tr>
<td>数词</td>
<td>numerals</td>
<td>表数量</td>
<td>i ate <strong>two</strong> carrots.</td>
</tr>
<tr>
<td>副词</td>
<td>adverbs</td>
<td>修饰动词或形容词</td>
<td>i ate two carrots <strong>quickly</strong>.</td>
</tr>
<tr>
<td>介词</td>
<td>prepositions</td>
<td>表示和其他词的关系</td>
<td>i ate two carrots <strong>with</strong> chopsticks.</td>
</tr>
<tr>
<td>叹词</td>
<td>interjections</td>
<td>表感叹</td>
<td><strong>ah</strong>, the carrot is tasty.</td>
</tr>
<tr>
<td>连词</td>
<td>conjunctions</td>
<td>连接词和句</td>
<td>i ate two carrots <strong>and</strong> a potato, <strong>because</strong> i was hungry.</td>
</tr>
<tr>
<td>动词</td>
<td>verbs</td>
<td>表动作</td>
<td>前面的重点，写好多了，这里不写了</td>
</tr>
</tbody></table>
<p>加幅图~ 看一下句子成分和词类的关系。<br><strong>每种句子成分，除了谓语动词一定是动词外，其他都可能包含不同的词类。</strong><br><img src="/images/articleimg/sentencesAndWords.png" alt="句子成分&amp;词类"></p>
<h3 id="谓语动词“三大本领”"><a href="#谓语动词“三大本领”" class="headerlink" title="谓语动词“三大本领”"></a>谓语动词“三大本领”</h3><p>表达动作的<strong>时间-状态-语气</strong>，也称ATM（Aspect-Tense-Mood）。<br>1.表示动作的时间：<br>2.表示动作的状态：<br>合称时态：<br>时态：就是谓语动词的时间和状态的排列组合！理论上有4种时间*4状态=16种时态。是英语难点之一，因为中文动词没有这个特性。<br>2.表示动作的假设、情感等：<br>也叫动词的<strong>语气</strong>，这是语法的“语气”（不是平时说话的语气。。）<br>虚拟语气：表意愿、和事实相反的假设等。if i <strong>were</strong> a rabbit.<br><img src="/images/articleimg/verb.png" alt="谓语动词的3个特点"><br>助动词：因为谓语动词往往不能独立完成ATM，也无法独立完成表示否定、可能性、必须性的意思。因此需要另一类词的帮助完成任务，即助动词。它没有实意，只是帮助谓语动词的小伙伴。<br>下面是它协助的一个小例子：<br><img src="/images/articleimg/auxiliaryVerbs.png" alt="助动词"><br>很多助动词，也可以做实义动词，甚至其他词性。<strong>千万不要把助动词和它的其他身份混淆</strong>。其他身份eg：can：易拉罐；do：做某事；have：拥有；be：存在。</p>
<h3 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h3><p>非谓语动词：<strong>是改动后的谓语动词</strong>。可以充当出谓语动词外的所有句子成分；取代几乎<strong>所有的从句</strong>，从而<strong>简化句子</strong>。但是非谓语动词同时也丧失了ATM的本领。。<br>它以不同形式出现在句中：有动词不定时、现在分词、动名词、过去分词，它们与谓语动词的不同状态看起来很像，需要结合句子成分区分，也是语法的一个难点。如下：<br><img src="/images/articleimg/verbs2.png" alt="非谓语动词的形式&amp;与谓语动词"></p>
<h3 id="太长不看版本"><a href="#太长不看版本" class="headerlink" title="太长不看版本"></a>太长不看版本</h3><p>英语语法的核心就是动词<br>动词<br>谓语动词<br>（囊括 主语，谓语动词，宾语，宾语补语，主语补语（表语））<br>  不及物动词—主 动<br>  单及物动词—主 动 宾<br>  双及物动词—主 动 间宾 直宾<br>  混合及物动词—主 动 宾 宾补<br>  系动词—主 动 表<br>  定语，状语，表语<br> 复合句（并列）<br> 复杂句（复杂）<br>  主句<br>  从句（可以充当所有句子成分）<br>   句子成分可以由词类充当（词类：动词，名词，代词，冠词，形容词，数词，副词，介词，叹词，连词）<br> 谓语动词可以表达ATM（时间，状态，语气）等，但是需要用到助动词<br>  助动词帮助否定动词表达时态 语气 否定 被动 可能 义务…<br>非谓语动词<br> 简化句子</p>
<p>英语语法细节很多，本文仅整理了一个脉络，如有错漏，请指正。</p>
<p>参考资料：<br>1.视频讲英语语法体系：<a href="https://www.bilibili.com/video/BV1r54y1m7gd?from=search&amp;seid=13838203267352976271">https://www.bilibili.com/video/BV1r54y1m7gd?from=search&amp;seid=13838203267352976271</a><br>2.补充语法概述资料：<a href="https://www.zhihu.com/question/30030877/answer/1253564096">https://www.zhihu.com/question/30030877/answer/1253564096</a></p>
]]></content>
      <categories>
        <category>英语语法</category>
      </categories>
      <tags>
        <tag>英语 - 语法</tag>
      </tags>
  </entry>
</search>
